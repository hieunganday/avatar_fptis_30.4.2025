<!DOCTYPE html>
<html lang="vi">
<head>
  <meta charset="UTF-8">
  <title>Hòa bình của chúng mình - FPT IS</title>
  <style>
    body {
      text-align: center;
      font-family: Arial, sans-serif;
      background: #f9f9f9;
    }
    #canvas {
      border: 1px solid #ccc;
      margin: 20px 0;
      touch-action: none; /* Cho phép thao tác 2 ngón trên mobile */
    }
    #rotateSlider {
      width: 800px;
      margin-top: 10px;
    }
    #buttons {
      margin-top: 20px;
    }
    #upload, #download {
      padding: 10px 20px;
      border: none;
      color: white;
      font-size: 16px;
      margin: 5px;
      cursor: pointer;
      border-radius: 5px;
    }
    #upload {
      background-color: #ff7f00; /* Cam */
    }
    #download {
      background-color: #007bff; /* Xanh dương */
    }
  </style>
</head>
<body>

  <h1>Hòa bình của chúng mình - FPT IS</h1>

  <canvas id="canvas" width="800" height="800"></canvas>

  <div>
    <input type="range" id="rotateSlider" min="0" max="360" value="0">
  </div>

  <div id="buttons">
    <label for="fileInput">
      <button id="upload">Upload Image</button>
    </label>
    <button id="download">Download Avatar</button>
    <input type="file" id="fileInput" accept="image/*" style="display: none;">
  </div>

  <script>
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    const rotateSlider = document.getElementById('rotateSlider');
    const fileInput = document.getElementById('fileInput');
    const uploadBtn = document.getElementById('upload');
    const downloadBtn = document.getElementById('download');

    let frame = new Image();
    frame.src = 'frame.png'; // Frame cố định

    let uploadedImage = null;
    let scale = 1;
    let rotation = 0;
    let posX = canvas.width / 2;
    let posY = canvas.height / 2;
    let isDragging = false;
    let startX, startY;
    let lastTouchDistance = null;

    fileInput.addEventListener('change', function(e) {
      const reader = new FileReader();
      reader.onload = function(event) {
        uploadedImage = new Image();
        uploadedImage.onload = function() {
          draw();
        }
        uploadedImage.src = event.target.result;
      }
      reader.readAsDataURL(e.target.files[0]);
    });

    uploadBtn.addEventListener('click', () => {
      fileInput.click();
    });

    downloadBtn.addEventListener('click', function() {
      const dataUrl = canvas.toDataURL('image/png');

      const link = document.createElement('a');
      link.href = dataUrl;
      link.download = 'avatar-fptis.png';
      link.click();
    });

    rotateSlider.addEventListener('input', function() {
      rotation = parseInt(this.value);
      draw();
    });

    canvas.addEventListener('mousedown', function(e) {
      isDragging = true;
      startX = e.offsetX;
      startY = e.offsetY;
    });

    canvas.addEventListener('mousemove', function(e) {
      if (isDragging) {
        const dx = e.offsetX - startX;
        const dy = e.offsetY - startY;
        posX += dx;
        posY += dy;
        startX = e.offsetX;
        startY = e.offsetY;
        draw();
      }
    });

    canvas.addEventListener('mouseup', function() {
      isDragging = false;
    });

    canvas.addEventListener('wheel', function(e) {
      e.preventDefault();
      if (e.deltaY < 0) {
        scale *= 1.05;
      } else {
        scale /= 1.05;
      }
      draw();
    });

    canvas.addEventListener('touchstart', function(e) {
      if (e.touches.length === 1) {
        isDragging = true;
        startX = e.touches[0].clientX - canvas.getBoundingClientRect().left;
        startY = e.touches[0].clientY - canvas.getBoundingClientRect().top;
      }
      if (e.touches.length === 2) {
        lastTouchDistance = getTouchDistance(e.touches);
      }
    });

    canvas.addEventListener('touchmove', function(e) {
      e.preventDefault();
      if (e.touches.length === 1 && isDragging) {
        const moveX = e.touches[0].clientX - canvas.getBoundingClientRect().left;
        const moveY = e.touches[0].clientY - canvas.getBoundingClientRect().top;
        const dx = moveX - startX;
        const dy = moveY - startY;
        posX += dx;
        posY += dy;
        startX = moveX;
        startY = moveY;
        draw();
      }
      if (e.touches.length === 2) {
        const newDistance = getTouchDistance(e.touches);
        if (lastTouchDistance) {
          if (newDistance > lastTouchDistance) {
            scale *= 1.02;
          } else {
            scale /= 1.02;
          }
          draw();
        }
        lastTouchDistance = newDistance;
      }
    });

    canvas.addEventListener('touchend', function(e) {
      if (e.touches.length < 2) {
        lastTouchDistance = null;
      }
      if (e.touches.length === 0) {
        isDragging = false;
      }
    });

    function getTouchDistance(touches) {
      const dx = touches[0].clientX - touches[1].clientX;
      const dy = touches[0].clientY - touches[1].clientY;
      return Math.sqrt(dx * dx + dy * dy);
    }

    function draw() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      if (uploadedImage) {
        ctx.save();
        ctx.translate(posX, posY);
        ctx.rotate(rotation * Math.PI / 180);
        ctx.scale(scale, scale);
        ctx.drawImage(uploadedImage, -uploadedImage.width / 2, -uploadedImage.height / 2);
        ctx.restore();
      }
      ctx.drawImage(frame, 0, 0, canvas.width, canvas.height);
    }

  </script>
</body>
</html>
