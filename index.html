<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Hòa bình của chúng mình - FPT IS</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            text-align: center;
            padding: 20px;
            background: #f0f0f0;
        }
        h1 {
            margin-bottom: 5px;
        }
        p {
            margin-bottom: 20px;
        }
        #preview-container {
            position: relative;
            width: 400px;
            height: 400px;
            margin: 0 auto;
            background: #fff;
            border: 2px solid #ccc;
            overflow: hidden;
            touch-action: none;
        }
        canvas {
            width: 100%;
            height: 100%;
            background: #ddd;
        }
        #controls {
            margin-top: 10px;
        }
        #controls input[type="range"] {
            width: 400px;
        }
        #buttons {
            margin-top: 15px;
        }
        #buttons button {
            margin: 5px;
            padding: 10px 15px;
            font-size: 16px;
        }
    </style>
</head>
<body>

    <h1>Hòa bình của chúng mình - FPT IS</h1>
    <p>Thay ava ngay</p>

    <div id="preview-container">
        <canvas id="preview" width="1200" height="1200"></canvas>
    </div>

    <div id="controls">
        <input type="range" id="rotate-slider" min="-180" max="180" value="0">
    </div>

    <div id="buttons">
        <button id="upload-frame-btn">Upload Frame</button>
        <button id="upload-avatar-btn">Upload Avatar</button>
        <button id="download-btn">Download Avatar</button>
    </div>

    <input type="file" id="frame-input" accept="image/*" style="display: none;">
    <input type="file" id="avatar-input" accept="image/*" style="display: none;">

    <script>
        const canvas = document.getElementById('preview');
        const ctx = canvas.getContext('2d');
        const rotateSlider = document.getElementById('rotate-slider');
        const uploadFrameBtn = document.getElementById('upload-frame-btn');
        const uploadAvatarBtn = document.getElementById('upload-avatar-btn');
        const downloadBtn = document.getElementById('download-btn');
        const frameInput = document.getElementById('frame-input');
        const avatarInput = document.getElementById('avatar-input');

        const canvasWidth = 1200; // chuẩn HD
        const canvasHeight = 1200;

        let frameImage = new Image();
        let avatarImage = new Image();
        let avatarLoaded = false;

        let avatar = {
            x: canvasWidth / 2,
            y: canvasHeight / 2,
            scale: 1,
            rotation: 0,
            dragging: false,
            offsetX: 0,
            offsetY: 0
        };

        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            if (avatarLoaded) {
                ctx.save();
                ctx.translate(avatar.x, avatar.y);
                ctx.rotate(avatar.rotation * Math.PI / 180);
                ctx.scale(avatar.scale, avatar.scale);
                const imgW = avatarImage.width;
                const imgH = avatarImage.height;
                ctx.drawImage(avatarImage, -imgW/2, -imgH/2);
                ctx.restore();
            }

            if (frameImage.src) {
                ctx.drawImage(frameImage, 0, 0, canvas.width, canvas.height);
            }
        }

        uploadFrameBtn.addEventListener('click', () => {
            frameInput.click();
        });

        frameInput.addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (file) {
                const url = URL.createObjectURL(file);
                frameImage.src = url;
                frameImage.onload = draw;
            }
        });

        uploadAvatarBtn.addEventListener('click', () => {
            avatarInput.click();
        });

        avatarInput.addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (file) {
                const url = URL.createObjectURL(file);
                avatarImage.src = url;
                avatarImage.onload = () => {
                    avatarLoaded = true;
                    draw();
                };
            }
        });

        rotateSlider.addEventListener('input', (e) => {
            avatar.rotation = parseFloat(e.target.value);
            draw();
        });

        downloadBtn.addEventListener('click', () => {
            const link = document.createElement('a');
            link.download = 'avatar_hd.png';
            link.href = canvas.toDataURL('image/png', 1.0); // chất lượng PNG full
            link.click();
        });

        // Dragging
        canvas.addEventListener('mousedown', (e) => {
            avatar.dragging = true;
            const rect = canvas.getBoundingClientRect();
            avatar.offsetX = (e.clientX - rect.left) * (canvas.width / rect.width) - avatar.x;
            avatar.offsetY = (e.clientY - rect.top) * (canvas.height / rect.height) - avatar.y;
        });

        canvas.addEventListener('mouseup', () => {
            avatar.dragging = false;
        });

        canvas.addEventListener('mouseleave', () => {
            avatar.dragging = false;
        });

        canvas.addEventListener('mousemove', (e) => {
            if (avatar.dragging) {
                const rect = canvas.getBoundingClientRect();
                avatar.x = (e.clientX - rect.left) * (canvas.width / rect.width) - avatar.offsetX;
                avatar.y = (e.clientY - rect.top) * (canvas.height / rect.height) - avatar.offsetY;
                draw();
            }
        });

        // Zoom with mouse wheel
        canvas.addEventListener('wheel', (e) => {
            e.preventDefault();
            const scaleAmount = e.deltaY * -0.001;
            avatar.scale += scaleAmount;
            avatar.scale = Math.min(Math.max(avatar.scale, 0.1), 5);
            draw();
        });

        // Zoom and move with touch gestures
        let lastTouchDist = null;
        let lastTouchPos = null;

        canvas.addEventListener('touchstart', (e) => {
            if (e.touches.length == 2) {
                lastTouchDist = getTouchDist(e.touches);
            } else if (e.touches.length == 1) {
                const rect = canvas.getBoundingClientRect();
                lastTouchPos = {
                    x: (e.touches[0].clientX - rect.left) * (canvas.width / rect.width),
                    y: (e.touches[0].clientY - rect.top) * (canvas.height / rect.height)
                };
            }
        });

        canvas.addEventListener('touchmove', (e) => {
            e.preventDefault();
            const rect = canvas.getBoundingClientRect();
            if (e.touches.length == 2) {
                const dist = getTouchDist(e.touches);
                const scaleChange = dist / lastTouchDist;
                avatar.scale *= scaleChange;
                avatar.scale = Math.min(Math.max(avatar.scale, 0.1), 5);
                lastTouchDist = dist;
            } else if (e.touches.length == 1 && lastTouchPos) {
                const newPos = {
                    x: (e.touches[0].clientX - rect.left) * (canvas.width / rect.width),
                    y: (e.touches[0].clientY - rect.top) * (canvas.height / rect.height)
                };
                avatar.x += newPos.x - lastTouchPos.x;
                avatar.y += newPos.y - lastTouchPos.y;
                lastTouchPos = newPos;
            }
            draw();
        });

        canvas.addEventListener('touchend', () => {
            lastTouchDist = null;
            lastTouchPos = null;
        });

        function getTouchDist(touches) {
            const dx = touches[0].clientX - touches[1].clientX;
            const dy = touches[0].clientY - touches[1].clientY;
            return Math.sqrt(dx * dx + dy * dy);
        }

        // Initial draw
        draw();
    </script>
</body>
</html>
